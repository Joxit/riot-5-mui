<material-input>
  <div class="label-placeholder"></div>
  <div class="input-content {state.value ? 'not-empty' : null } { state.error ? 'error': null }">
    <label for="input" if="{props.label}">{props.label}</label>
    <input type="{props.type||'text'}" disabled="{state.disabled}" placeholder="{props.placeholder}" onkeyup="{changeValue}" value="{state.value}" autocomplete="off" required="{state.required}" />
    <div class="iconWrapper" if="{props.icon}">
      <material-button inverted center="true" waves-center="true" waves-color="{props['waves-color']||'#fff'}" icon="true" onclick="{iconClickHandler}" waves-opacity="{props['waves-opacity']||'0.6'}" waves-duration="{props['waves-duration']||'600'}">
        <slot />
      </material-button>
    </div>
  </div>
  <div if="{!state.outlined && !state.rounded}" class="underline {state.focused ? 'focused' : null} {state.error ? 'error' : null}">
    <div class="unfocused-line"></div>
    <div class="focused-line"></div>
  </div>

  <script>
    import Validate from '../../mixins/validate';
    const SUPPORTED_ATTRIBUTES = ['disabled', 'rounded', 'outlined', 'inverted'];
    import MaterialButton from '../material-button/material-button.riot';
    import {
      attributeToBool,
      HTML,
      attributesObj
    } from '../../mixins/utilities';
    export default {
      state: {
        focused: false,
        showIcon: false,
        value: '',
        disabled: false,
        required: false,
        error: false,
        attributes: {},
      },
      components: {
        MaterialButton
      },
      onMounted(props, state) {
        this.required = "";
        // Not supported types
        this.notSupportedTypes = ['date', 'color', 'datetime', 'month', 'range', 'time'];
        if (this.notSupportedTypes.indexOf(this.props.type) != -1) throw new Error(`Sorry but we do not support ${this.props.type} type yet!`);
        this.validator = new Validate(this.props);
        // Attributes
        this.update({
          showIcon: false,
          value: this.props.value || '',
          ...attributesObj(SUPPORTED_ATTRIBUTES, props)
        });

        this.$('input').addEventListener('focus', this.changeFocus);
        this.$('input').addEventListener('blur', this.changeFocus);
        this.updateAttributes(props, state);
      },
      onBeforeUpdate(props, states) {
        this.state.value = this.$('input').value;
        this.state.error = states.value.length !== 0 && !this.validator.validate(states.value)
      },
      onUpdated(props, state) {
        this.updateAttributes(props, state);
      },
      updateAttributes(props, state) {
        const attributes = attributesObj(SUPPORTED_ATTRIBUTES, props)
        if (attributes.outlined || attributes.rounded) {
          this.$('.input-content').style['border-color'] = props.color;
          this.$('input').style.color = props.textColor;
        } else if (attributes.inverted) {
          HTML.children(this.$('.underline')).forEach(e => e.style.background = props.textColor);
          this.$('input').style.color = props.color;
        } else {
          HTML.children(this.$('.underline')).forEach(e => e.style.background = props.color);
          this.$('input').style.color = props.textColor;
        }
      },
      /**
       * When element focus changed update expressions.
       */
      changeFocus(e) {
        if (this.disabled) return false;
        this.update({
          focused: this.$('input') == document.activeElement
        });
        if (this.props.focuschanged && (typeof(this.props.focuschanged) === "function")) {
          this.props.focuschanged(this.focused, e);
        }
      },
      /**
       * Change input value should change tag behavior.
       * @param e
       */
      changeValue(e) {
        this.update({
          value: this.$('input').value
        });
        if (this.props.valuechanged && (typeof(this.props.valuechanged) === "function")) {
          this.props.valuechanged(this.$('input').value, e);
        }
      },
      /**
       * Fire clicking on icon to outside world
       * @param e
       */
      iconClickHandler(e) {
        if (this.props.iconclicked && typeof this.props.iconclicked === 'function') {
          this.props.iconclicked.call(this, e);
        }
      }
    }
  </script>
</material-input>